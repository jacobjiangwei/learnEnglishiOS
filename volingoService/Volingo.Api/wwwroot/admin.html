<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volingo æ•™æç®¡ç†åå°</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            line-height: 1.6;
        }
        .container { max-width: 1000px; margin: 0 auto; padding: 24px; }
        h1 { font-size: 28px; font-weight: 700; margin-bottom: 8px; }
        .subtitle { color: #86868b; margin-bottom: 32px; }
        /* Tabs */
        .tab-bar {
            display: flex; gap: 0; margin-bottom: 24px;
            background: #e5e5ea; border-radius: 10px; padding: 3px;
        }
        .tab-btn {
            flex: 1; padding: 10px 16px; border: none; background: transparent;
            font-size: 15px; font-weight: 600; cursor: pointer;
            border-radius: 8px; transition: all 0.15s; color: #666;
        }
        .tab-btn.active { background: #fff; color: #1d1d1f; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .card {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        .card h2 {
            font-size: 18px; font-weight: 600; margin-bottom: 16px;
            display: flex; align-items: center; gap: 8px;
        }
        .card h2 .step {
            background: #007aff; color: #fff;
            width: 28px; height: 28px; border-radius: 50%;
            display: inline-flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: 700;
        }
        label { display: block; font-weight: 500; margin-bottom: 6px; font-size: 14px; }
        select, input[type="file"] {
            width: 100%; padding: 10px 12px;
            border: 1px solid #d2d2d7; border-radius: 8px;
            font-size: 15px; background: #fff; margin-bottom: 12px;
        }
        select:focus { outline: none; border-color: #007aff; box-shadow: 0 0 0 3px rgba(0,122,255,0.15); }
        .row { display: flex; gap: 16px; }
        .row > * { flex: 1; }
        .btn {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 10px 20px; border: none; border-radius: 8px;
            font-size: 15px; font-weight: 600; cursor: pointer;
            transition: all 0.15s;
        }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: #007aff; color: #fff; }
        .btn-primary:hover:not(:disabled) { background: #0062cc; }
        .btn-success { background: #34c759; color: #fff; }
        .btn-success:hover:not(:disabled) { background: #28a745; }
        .btn-danger { background: #ff3b30; color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #d63027; }
        .btn-analyze { background: #8b5cf6; color: #fff; }
        .btn-analyze:hover:not(:disabled) { background: #7c3aed; }
        .btn-orange { background: #ff9500; color: #fff; }
        .btn-orange:hover:not(:disabled) { background: #e68600; }
        .btn-sm { padding: 6px 12px; font-size: 13px; }
        .preview-box {
            background: #fafafa; border: 1px solid #e5e5ea; border-radius: 8px;
            padding: 16px; max-height: 500px; overflow-y: auto;
            font-family: "SF Mono", Monaco, monospace; font-size: 13px;
            white-space: pre-wrap; word-break: break-all; display: none;
        }
        .status {
            padding: 12px 16px; border-radius: 8px; margin-top: 12px;
            font-size: 14px; display: none;
        }
        .status.info    { background: #e8f4fd; color: #0a84ff; display: block; }
        .status.success { background: #e8fae8; color: #248a3d; display: block; }
        .status.error   { background: #fde8e8; color: #ff3b30; display: block; }
        .status.loading { background: #fff8e1; color: #ff9500; display: block; }
        .inventory-table { width: 100%; border-collapse: collapse; font-size: 14px; }
        .inventory-table th {
            text-align: left; padding: 10px 12px;
            background: #f5f5f7; border-bottom: 2px solid #e5e5ea; font-weight: 600;
        }
        .inventory-table td { padding: 8px 12px; border-bottom: 1px solid #f0f0f0; }
        .inventory-table tr:hover td { background: #f5f5f7; }
        .badge {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 12px; font-weight: 600;
        }
        .badge-done { background: #e8fae8; color: #248a3d; }
        .badge-empty { background: #f0f0f0; color: #86868b; }
        .badge-ai { background: #f3e8ff; color: #8b5cf6; }
        .spinner {
            display: inline-block; width: 16px; height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid #fff; border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .meta { display: flex; gap: 16px; margin-top: 8px; font-size: 13px; color: #86868b; }
        .meta span { display: flex; align-items: center; gap: 4px; }
        /* Modal */
        .modal-overlay {
            display: none; position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;
        }
        .modal-overlay.active { display: flex; justify-content: center; padding: 40px 20px; }
        .modal {
            background: #fff; border-radius: 16px;
            max-width: 860px; width: 100%;
            max-height: calc(100vh - 80px); overflow-y: auto;
            padding: 32px; position: relative;
        }
        .modal-close {
            position: absolute; top: 16px; right: 16px;
            background: #f0f0f0; border: none;
            width: 32px; height: 32px; border-radius: 50%;
            font-size: 18px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .modal-close:hover { background: #e0e0e0; }
        .modal h2 { font-size: 22px; margin-bottom: 20px; }
        .unit-card {
            border: 1px solid #e5e5ea; border-radius: 12px;
            padding: 20px; margin-bottom: 16px;
        }
        .unit-card h3 { font-size: 16px; font-weight: 700; margin-bottom: 12px; color: #007aff; }
        .unit-section { margin-bottom: 12px; }
        .unit-section h4 {
            font-size: 13px; font-weight: 700; color: #86868b;
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;
        }
        .tag-list { display: flex; flex-wrap: wrap; gap: 6px; }
        .tag {
            display: inline-block; padding: 3px 10px; border-radius: 12px;
            font-size: 13px; background: #e8f4fd; color: #0a84ff;
        }
        .tag.vocab { background: #fff3e0; color: #ff9500; }
        .tag.grammar { background: #f3e8ff; color: #8b5cf6; }
        .tag.command { background: #e8fae8; color: #248a3d; }
        .tag.song { background: #fde8e8; color: #ff3b30; }
        .sentence-item {
            padding: 4px 0; font-size: 14px; border-bottom: 1px solid #f5f5f5;
        }
        .sentence-item:last-child { border-bottom: none; }
        .sentence-pattern { font-weight: 600; color: #1d1d1f; }
        .sentence-usage { color: #86868b; font-size: 13px; margin-left: 8px; }
        .story-box {
            background: #fafafa; border-radius: 8px; padding: 12px;
            font-size: 14px; color: #333;
        }
        /* Glossary table */
        .glossary-table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
        .glossary-table th {
            text-align: left; padding: 6px 8px; background: #f5f5f7;
            border-bottom: 2px solid #e5e5ea; font-size: 12px; font-weight: 600;
        }
        .glossary-table td { padding: 4px 8px; border-bottom: 1px solid #f0f0f0; }
        /* Question generation */
        .type-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 16px; }
        .type-card {
            border: 2px solid #e5e5ea; border-radius: 10px; padding: 12px;
            cursor: pointer; transition: all 0.15s; text-align: center;
        }
        .type-card:hover { border-color: #007aff; background: #f0f7ff; }
        .type-card.selected { border-color: #007aff; background: #e8f4fd; }
        .type-card.done { border-color: #34c759; background: #e8fae8; opacity: 0.7; }
        .type-card .type-icon { font-size: 20px; margin-bottom: 4px; }
        .type-card .type-name { font-size: 13px; font-weight: 700; }
        .type-card .type-count { font-size: 11px; color: #86868b; margin-top: 2px; }
        .question-preview {
            background: #1d1d1f; color: #f5f5f7; border-radius: 10px;
            padding: 16px; max-height: 600px; overflow-y: auto;
            font-family: "SF Mono", Monaco, monospace; font-size: 12px;
            white-space: pre-wrap; word-break: break-all; margin: 12px 0;
        }
        .question-stats {
            display: flex; gap: 12px; flex-wrap: wrap; margin: 12px 0;
        }
        .question-stats .stat {
            background: #f5f5f7; border-radius: 8px; padding: 8px 14px;
            font-size: 13px; font-weight: 600;
        }
        .question-stats .stat .num { font-size: 20px; color: #007aff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“š Volingo æ•™æç®¡ç†åå°</h1>
        <p class="subtitle">æ•™æå¯¼å…¥ Â· AI åˆ†æ Â· æ™ºèƒ½å‡ºé¢˜ Â· é¢˜åº“ç®¡ç†</p>

        <!-- Tab bar -->
        <div class="tab-bar">
            <button class="tab-btn active" onclick="switchTab('import')">ğŸ“„ æ•™æå¯¼å…¥</button>
            <button class="tab-btn" onclick="switchTab('generate')">ğŸ¤– AI å‡ºé¢˜</button>
            <button class="tab-btn" onclick="switchTab('reports')">ğŸš¨ é”™é¢˜å·¥å• <span id="reportBadge" style="background:#ff3b30;color:#fff;border-radius:10px;padding:1px 7px;font-size:11px;margin-left:4px;display:none;"></span></button>
        </div>

        <!-- ==================== TAB: IMPORT ==================== -->
        <div class="tab-content active" id="tab-import">

        <!-- Step 1: Select textbook -->
        <div class="card">
            <h2><span class="step">1</span> é€‰æ‹©æ•™æ</h2>
            <div class="row">
                <div>
                    <label>æ•™æç‰ˆæœ¬</label>
                    <select id="seriesSelect" onchange="onSeriesChange()">
                        <option value="">â€” é€‰æ‹©æ•™æç‰ˆæœ¬ â€”</option>
                    </select>
                </div>
                <div>
                    <label>å†Œæ¬¡</label>
                    <select id="volumeSelect" disabled>
                        <option value="">â€” å…ˆé€‰æ•™æç‰ˆæœ¬ â€”</option>
                    </select>
                </div>
            </div>
            <div class="meta" id="selectionMeta" style="display:none">
                <span>ğŸ“ ID: <strong id="previewId"></strong></span>
                <span>ğŸ“– <span id="previewDisplay"></span></span>
            </div>
        </div>

        <!-- Step 2: Upload PDF -->
        <div class="card">
            <h2><span class="step">2</span> ä¸Šä¼  PDF å¹¶æå–</h2>
            <input type="file" id="pdfFile" accept=".pdf">
            <button class="btn btn-primary" id="extractBtn" onclick="extractPdf()" disabled>
                ğŸ” æå–æ–‡æœ¬
            </button>
            <div class="status" id="extractStatus"></div>
        </div>

        <!-- Step 3: Preview -->
        <div class="card" id="previewCard" style="display:none">
            <h2><span class="step">3</span> é¢„è§ˆæå–ç»“æœ</h2>
            <div class="meta" id="extractMeta">
                <span>ğŸ“„ é¡µæ•°: <strong id="metaPages">0</strong></span>
                <span>ğŸ“ å­—ç¬¦: <strong id="metaChars">0</strong></span>
            </div>
            <div class="preview-box" id="previewContent" style="display:block; margin-top:12px"></div>
            <div style="margin-top: 16px; display: flex; gap: 12px;">
                <button class="btn btn-success" id="saveBtn" onclick="saveToDb()">
                    âœ… ç¡®è®¤å­˜å…¥ Cosmos DB
                </button>
                <button class="btn btn-danger" onclick="clearPreview()">
                    âŒ æ”¾å¼ƒ
                </button>
            </div>
            <div class="status" id="saveStatus"></div>
        </div>

        <!-- Inventory -->
        <div class="card">
            <h2>ğŸ“Š å·²å…¥åº“æ–‡æ¡£</h2>
            <button class="btn btn-primary btn-sm" onclick="loadInventory()" style="margin-bottom: 12px;">
                ğŸ”„ åˆ·æ–°
            </button>
            <div id="inventoryContent">
                <p style="color: #86868b; font-size: 14px;">ç‚¹å‡»åˆ·æ–°æŸ¥çœ‹å·²å…¥åº“æ–‡æ¡£</p>
            </div>
        </div>

        <!-- Analysis Modal -->
        </div><!-- end tab-import -->

        <!-- ==================== TAB: GENERATE ==================== -->
        <div class="tab-content" id="tab-generate">

            <!-- Step G1: Select document -->
            <div class="card">
                <h2><span class="step">1</span> é€‰æ‹©å·²åˆ†æçš„æ•™æ</h2>
                <select id="genDocSelect" onchange="onGenDocChange()">
                    <option value="">â€” é€‰æ‹©æ•™ææ–‡æ¡£ â€”</option>
                </select>
                <div id="genDocInfo" style="display:none" class="meta"></div>
            </div>

            <!-- Step G2: Select unit -->
            <div class="card" id="genUnitCard" style="display:none">
                <h2><span class="step">2</span> é€‰æ‹©å•å…ƒ</h2>
                <select id="genUnitSelect" onchange="onGenUnitChange()">
                    <option value="">â€” é€‰æ‹©å•å…ƒ â€”</option>
                </select>
                <div id="genUnitInfo" style="display:none">
                    <div class="meta" style="margin-bottom:8px">
                        <span>ğŸ“ è¯æ±‡: <strong id="genUnitVocab">0</strong> ä¸ª</span>
                        <span>ğŸ’¬ å¥å‹: <strong id="genUnitPatterns">0</strong> æ¡</span>
                        <span>ğŸ“ è¯­æ³•: <strong id="genUnitGrammar">0</strong> ä¸ª</span>
                    </div>
                    <!-- Unit detail preview: what AI will see -->
                    <div id="genUnitDetail" style="margin-top:12px;background:#f9f9fb;border:1px solid #e5e5ea;border-radius:10px;padding:16px;font-size:13px;max-height:400px;overflow-y:auto;">
                    </div>
                </div>
            </div>

            <!-- Step G3: Select question type & generate -->
            <div class="card" id="genTypeCard" style="display:none">
                <h2><span class="step">3</span> é€‰æ‹©é¢˜å‹</h2>
                <p style="font-size:13px;color:#86868b;margin-bottom:12px;">
                    é€‰æ‹©ä¸€ç§é¢˜å‹ï¼ŒAI å°†ä¸ºè¯¥å•å…ƒç”Ÿæˆå¯¹åº”çš„ç»ƒä¹ é¢˜ã€‚å¯é€ä¸ªç”Ÿæˆã€å®¡æ ¸ã€å…¥åº“ã€‚
                </p>
                <div class="type-grid" id="typeGrid"></div>
                <button class="btn btn-orange" id="generateBtn" onclick="generateQuestions()" disabled>
                    ğŸ¤– ç”Ÿæˆé¢˜ç›®
                </button>
                <div class="status" id="genStatus"></div>
            </div>

            <!-- Full-book generation: server-side background job -->
            <div class="card" id="genFullBookCard" style="display:none">
                <h2>ğŸ“š æ•´ä¹¦ä¸€é”®å‡ºé¢˜</h2>
                <p style="font-size:13px;color:#86868b;margin-bottom:12px;">
                    æœåŠ¡å™¨åå°è‡ªåŠ¨éå†æ‰€æœ‰å•å…ƒ Ã— 11 ç§é¢˜å‹ï¼Œç”Ÿæˆå¹¶å…¥åº“ã€‚ç†Šå±/åˆ‡é¡µä¸å½±å“è¿›åº¦ã€‚
                </p>
                <div id="fullBookProgress" style="display:none;margin-bottom:12px;">
                    <div style="display:flex;justify-content:space-between;font-size:13px;margin-bottom:4px;">
                        <span id="fullBookProgressText">0%</span>
                        <span id="fullBookProgressCount">0/0</span>
                    </div>
                    <div style="background:#e5e5ea;border-radius:4px;height:8px;overflow:hidden;">
                        <div id="fullBookProgressBar" style="background:#007aff;height:100%;width:0%;transition:width 0.3s;border-radius:4px;"></div>
                    </div>
                    <div id="fullBookSummary" style="margin-top:8px;font-size:13px;color:#1d1d1f;"></div>
                    <div id="fullBookLog" style="margin-top:8px;font-size:12px;color:#86868b;max-height:300px;overflow-y:auto;font-family:monospace;line-height:1.6;"></div>
                </div>
                <div style="display:flex;gap:12px;">
                    <button class="btn btn-analyze" id="fullBookBtn" onclick="startFullBookJob()">
                        ğŸ“š å¼€å§‹æ•´ä¹¦å‡ºé¢˜
                    </button>
                    <button class="btn btn-danger btn-sm" id="fullBookCancelBtn" onclick="cancelFullBookJob()" style="display:none">
                        â¹ åœæ­¢
                    </button>
                    <button class="btn btn-sm" id="fullBookResumeBtn" onclick="resumeFullBookJob()" style="display:none;background:#ff9500;color:#fff;">
                        â–¶ï¸ æ¢å¤
                    </button>
                </div>
                <div class="status" id="fullBookStatus"></div>
            </div>

            <!-- Step G4: Review & commit -->
            <div class="card" id="genResultCard" style="display:none">
                <h2><span class="step">4</span> å®¡æ ¸é¢˜ç›® & ç¡®è®¤å…¥åº“</h2>
                <div class="question-stats" id="genStats"></div>
                <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;">
                    <button class="btn btn-sm btn-primary" onclick="toggleJsonView()">
                        ğŸ“‹ å±•å¼€/æ”¶èµ· JSON
                    </button>
                    <button class="btn btn-sm" id="evalBtn" onclick="evalQuestions()" style="background:#8b5cf6;color:#fff">
                        ğŸ” AI è´¨æ£€
                    </button>
                    <button class="btn btn-sm" onclick="toggleAllQuestions(true)" style="background:#34c759;color:#fff">
                        âœ… å…¨é€‰
                    </button>
                    <button class="btn btn-sm" onclick="toggleAllQuestions(false)" style="background:#ff9500;color:#fff">
                        â˜ å…¨ä¸é€‰
                    </button>
                </div>
                <div class="status" id="evalStatus"></div>
                <div class="question-preview" id="genJsonPreview" style="display:none"></div>

                <!-- Per-question visual cards with checkboxes -->
                <div id="genQuestionCards" style="margin:12px 0;max-height:500px;overflow-y:auto;"></div>

                <div style="display:flex;gap:12px;margin-top:16px;align-items:center;">
                    <button class="btn btn-success" id="commitBtn" onclick="commitQuestions()">
                        âœ… ç¡®è®¤å…¥åº“é¢˜åº“
                    </button>
                    <span id="commitCount" style="font-size:13px;color:#86868b;"></span>
                    <button class="btn btn-danger" onclick="discardQuestions()">
                        âŒ ä¸¢å¼ƒ
                    </button>
                </div>
                <div class="status" id="commitStatus"></div>
            </div>

        </div><!-- end tab-generate -->

        <!-- ==================== TAB: REPORTS ==================== -->
        <div class="tab-content" id="tab-reports">
            <div class="card">
                <h2>ğŸš¨ é”™é¢˜ä¸¾æŠ¥å·¥å•</h2>
                <p style="font-size:13px;color:#86868b;margin-bottom:16px;">
                    ç”¨æˆ·åœ¨åšé¢˜æ—¶ä¸¾æŠ¥çš„é—®é¢˜é¢˜ç›®ï¼ŒæŒ‰è¢«ä¸¾æŠ¥æ¬¡æ•°ä»é«˜åˆ°ä½æ’åˆ—ã€‚ç‚¹å‡»æŸ¥çœ‹é¢˜ç›®å†…å®¹ï¼Œç¡®è®¤åå¯åˆ é™¤é”™é¢˜ã€‚
                </p>
                <div style="display:flex;gap:12px;margin-bottom:16px;align-items:center;">
                    <button class="btn btn-primary btn-sm" onclick="loadReportTickets()">ğŸ”„ åˆ·æ–°</button>
                    <span id="reportSummary" style="font-size:13px;color:#86868b;"></span>
                </div>
                <div id="reportTicketList">
                    <p style="color:#86868b;font-size:14px;">åŠ è½½ä¸­â€¦</p>
                </div>
                <div id="reportPaging" style="display:none;margin-top:16px;display:flex;gap:12px;align-items:center;justify-content:center;">
                    <button class="btn btn-sm" id="reportPrevBtn" onclick="reportPagePrev()" disabled>â¬… ä¸Šä¸€é¡µ</button>
                    <span id="reportPageInfo" style="font-size:13px;color:#86868b;"></span>
                    <button class="btn btn-sm" id="reportNextBtn" onclick="reportPageNext()">ä¸‹ä¸€é¡µ â¡</button>
                </div>
            </div>
        </div><!-- end tab-reports -->

        <!-- Report Question Detail Modal -->
        <div class="modal-overlay" id="reportDetailModal">
            <div class="modal">
                <button class="modal-close" onclick="closeReportDetailModal()">âœ•</button>
                <h2 id="reportModalTitle">ğŸ“‹ é¢˜ç›®è¯¦æƒ…</h2>
                <div id="reportModalContent"></div>
            </div>
        </div>

        <!-- Analysis Modal -->
        <div class="modal-overlay" id="analysisModal">
            <div class="modal">
                <button class="modal-close" onclick="closeAnalysisModal()">âœ•</button>
                <h2 id="modalTitle">ğŸ“– çŸ¥è¯†ç‚¹åˆ†æ</h2>
                <div id="modalContent"></div>
            </div>
        </div>
    </div>

    <script>
        const API = "/api/v1/admin";
        let textbooks = [];
        let extractedContent = "";
        let extractedPages = 0;

        // â”€â”€ Init â”€â”€
        async function init() {
            const resp = await fetch(`${API}/textbooks`);
            textbooks = await resp.json();
            const sel = document.getElementById("seriesSelect");

            const groups = {};
            textbooks.forEach(t => {
                const parts = t.displayName.split("Â·");
                const group = parts.length > 1 ? parts[0] : "å…¶ä»–";
                if (!groups[group]) groups[group] = [];
                groups[group].push(t);
            });

            for (const [group, items] of Object.entries(groups)) {
                const optgroup = document.createElement("optgroup");
                optgroup.label = group;
                items.forEach(t => {
                    const opt = document.createElement("option");
                    opt.value = t.seriesCode;
                    opt.textContent = t.displayName;
                    optgroup.appendChild(opt);
                });
                sel.appendChild(optgroup);
            }

            // Auto-refresh inventory on page load
            loadInventory();
        }

        async function onSeriesChange() {
            const code = document.getElementById("seriesSelect").value;
            const volSel = document.getElementById("volumeSelect");
            volSel.innerHTML = "";

            if (!code) {
                volSel.disabled = true;
                volSel.innerHTML = '<option value="">â€” å…ˆé€‰æ•™æç‰ˆæœ¬ â€”</option>';
                updatePreviewId();
                return;
            }

            const tb = textbooks.find(t => t.seriesCode === code);
            if (!tb.isGradeSync) {
                volSel.disabled = true;
                volSel.innerHTML = '<option value="">ï¼ˆæ— éœ€é€‰æ‹©å†Œæ¬¡ï¼‰</option>';
                updatePreviewId();
                updateExtractBtn();
                return;
            }

            const resp = await fetch(`${API}/textbooks/${code}/volumes`);
            const volumes = await resp.json();

            volSel.disabled = false;
            volSel.innerHTML = '<option value="">â€” é€‰æ‹©å†Œæ¬¡ â€”</option>';
            volumes.forEach(v => {
                const opt = document.createElement("option");
                opt.value = v.volume;
                opt.textContent = v.display;
                volSel.appendChild(opt);
            });

            volSel.onchange = () => { updatePreviewId(); updateExtractBtn(); };
            updatePreviewId();
            updateExtractBtn();
        }

        function updatePreviewId() {
            const code = document.getElementById("seriesSelect").value;
            const vol = document.getElementById("volumeSelect").value;
            const meta = document.getElementById("selectionMeta");

            if (!code) { meta.style.display = "none"; return; }

            const tb = textbooks.find(t => t.seriesCode === code);
            let id = code;
            if (tb.isGradeSync && vol) {
                id = `${code}-${vol}`;
            } else if (tb.isGradeSync && !vol) {
                meta.style.display = "none";
                return;
            }

            document.getElementById("previewId").textContent = id;
            document.getElementById("previewDisplay").textContent =
                tb.displayName + (vol ? ` Â· ${document.getElementById("volumeSelect").selectedOptions[0]?.text || ""}` : "");
            meta.style.display = "flex";
        }

        function updateExtractBtn() {
            const code = document.getElementById("seriesSelect").value;
            const vol = document.getElementById("volumeSelect").value;
            const file = document.getElementById("pdfFile").files[0];
            const tb = textbooks.find(t => t.seriesCode === code);
            const ready = code && file && (!tb?.isGradeSync || vol);
            document.getElementById("extractBtn").disabled = !ready;
        }

        document.getElementById("pdfFile").addEventListener("change", updateExtractBtn);

        // â”€â”€ Extract â”€â”€
        async function extractPdf() {
            const file = document.getElementById("pdfFile").files[0];
            if (!file) return;

            const btn = document.getElementById("extractBtn");
            const status = document.getElementById("extractStatus");

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> æå–ä¸­â€¦';
            status.className = "status loading";
            status.textContent = `æ­£åœ¨ä¸Šä¼  ${file.name} (${(file.size / 1024 / 1024).toFixed(1)} MB) å¹¶è°ƒç”¨ Azure Doc Intelligenceâ€¦`;

            const formData = new FormData();
            formData.append("file", file);

            try {
                const resp = await fetch(`${API}/extract`, { method: "POST", body: formData });
                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || "æå–å¤±è´¥");
                }
                const data = await resp.json();

                extractedContent = data.content;
                extractedPages = data.totalPages;

                document.getElementById("previewCard").style.display = "block";
                document.getElementById("previewContent").textContent = data.content;
                document.getElementById("metaPages").textContent = data.totalPages;
                document.getElementById("metaChars").textContent = data.charCount.toLocaleString();

                status.className = "status success";
                status.textContent = `âœ… æå–å®Œæˆ: ${data.totalPages} é¡µ, ${data.charCount.toLocaleString()} å­—ç¬¦`;
            } catch (e) {
                status.className = "status error";
                status.textContent = `âŒ ${e.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = "ğŸ” æå–æ–‡æœ¬";
                updateExtractBtn();
            }
        }

        // â”€â”€ Save â”€â”€
        async function saveToDb() {
            const code = document.getElementById("seriesSelect").value;
            const vol = document.getElementById("volumeSelect").value;
            const btn = document.getElementById("saveBtn");
            const status = document.getElementById("saveStatus");

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> ä¿å­˜ä¸­â€¦';

            try {
                const resp = await fetch(`${API}/save`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        seriesCode: code,
                        volume: vol || null,
                        rawContent: extractedContent,
                        totalPages: extractedPages,
                    }),
                });
                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || "ä¿å­˜å¤±è´¥");
                }
                const data = await resp.json();

                status.className = "status success";
                status.textContent = `âœ… å·²ä¿å­˜: ${data.id} (${data.displayName}), ${data.totalPages} é¡µ, ${data.charCount.toLocaleString()} å­—ç¬¦`;
                loadInventory();
            } catch (e) {
                status.className = "status error";
                status.textContent = `âŒ ${e.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = "âœ… ç¡®è®¤å­˜å…¥ Cosmos DB";
            }
        }

        function clearPreview() {
            document.getElementById("previewCard").style.display = "none";
            extractedContent = "";
            extractedPages = 0;
        }

        // â”€â”€ Inventory â”€â”€
        async function loadInventory() {
            const container = document.getElementById("inventoryContent");
            container.innerHTML = '<p style="color: #86868b;">åŠ è½½ä¸­â€¦</p>';

            try {
                const resp = await fetch(`${API}/documents`);
                const docs = await resp.json();

                if (docs.length === 0) {
                    container.innerHTML = '<p style="color: #86868b;">æš‚æ— å·²å…¥åº“æ–‡æ¡£</p>';
                    return;
                }

                let html = `<table class="inventory-table">
                    <thead><tr>
                        <th>ID</th><th>æ•™æ</th><th>å†Œæ¬¡</th><th>é¡µæ•°</th><th>AI åˆ†æ</th><th>æ›´æ–°æ—¶é—´</th><th>æ“ä½œ</th>
                    </tr></thead><tbody>`;

                docs.sort((a, b) => a.id.localeCompare(b.id));
                docs.forEach(doc => {
                    const updated = doc.updatedAt ? new Date(doc.updatedAt).toLocaleString("zh-CN") : "-";
                    const hasAI = doc.hasAnalysis;
                    const aiBadge = hasAI
                        ? '<span class="badge badge-ai">âœ… å·²åˆ†æ</span>'
                        : '<span class="badge badge-empty">æœªåˆ†æ</span>';
                    html += `<tr>
                        <td><code>${doc.id}</code></td>
                        <td>${doc.displayName || doc.textbook}</td>
                        <td>${doc.volume || "-"}</td>
                        <td>${doc.totalPages || 0}</td>
                        <td>${aiBadge}</td>
                        <td>${updated}</td>
                        <td style="display:flex;gap:6px;flex-wrap:wrap;">
                            <button class="btn btn-analyze btn-sm" onclick="analyzeDoc('${doc.id}','${doc.textbook}', this)">
                                ğŸ¤– ${hasAI ? 'é‡æ–°åˆ†æ' : 'AI åˆ†æ'}
                            </button>
                            ${hasAI ? `<button class="btn btn-primary btn-sm" onclick="viewAnalysis('${doc.id}','${doc.textbook}')">ğŸ“– æŸ¥çœ‹</button>` : ''}
                            <button class="btn btn-danger btn-sm" onclick="deleteDoc('${doc.id}','${doc.textbook}')">åˆ é™¤</button>
                        </td>
                    </tr>`;
                });
                html += "</tbody></table>";
                html += `<p style="color: #86868b; margin-top:8px; font-size:13px;">å…± ${docs.length} æ¡è®°å½•</p>`;
                container.innerHTML = html;
            } catch (e) {
                container.innerHTML = `<p style="color: #ff3b30;">åŠ è½½å¤±è´¥: ${e.message}</p>`;
            }
        }

        async function deleteDoc(id, textbook) {
            if (!confirm(`ç¡®è®¤åˆ é™¤ ${id}ï¼Ÿ`)) return;
            try {
                const resp = await fetch(`${API}/documents/${id}?textbook=${encodeURIComponent(textbook)}`, { method: "DELETE" });
                if (resp.ok) loadInventory();
            } catch (e) {
                alert("åˆ é™¤å¤±è´¥: " + e.message);
            }
        }

        // â”€â”€ AI Analysis â”€â”€
        async function analyzeDoc(id, textbook, btn) {
            if (!confirm(`å¯¹ ${id} è¿è¡Œ GPT-4o åˆ†æï¼Ÿ\nï¼ˆå¯èƒ½éœ€è¦ 30-60 ç§’ï¼‰`)) return;

            const origText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner" style="border-top-color:#fff"></span> åˆ†æä¸­â€¦';

            try {
                const resp = await fetch(`${API}/analyze/${id}?textbook=${encodeURIComponent(textbook)}`, {
                    method: "POST",
                });
                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || "åˆ†æå¤±è´¥");
                }
                const data = await resp.json();
                alert(`âœ… åˆ†æå®Œæˆï¼å…±æå– ${data.unitCount} ä¸ªå•å…ƒçš„çŸ¥è¯†ç‚¹ã€‚`);
                loadInventory();
                showAnalysis(data.analysis, data.displayName);
            } catch (e) {
                alert(`âŒ åˆ†æå¤±è´¥: ${e.message}`);
            } finally {
                btn.disabled = false;
                btn.innerHTML = origText;
            }
        }

        async function viewAnalysis(id, textbook) {
            try {
                const resp = await fetch(`${API}/documents/${id}/analysis?textbook=${encodeURIComponent(textbook)}`);
                const data = await resp.json();
                if (!data.hasAnalysis) {
                    alert("è¯¥æ–‡æ¡£å°šæœªè¿›è¡Œ AI åˆ†æ");
                    return;
                }
                showAnalysis(data.analysis, data.displayName);
            } catch (e) {
                alert("åŠ è½½åˆ†æç»“æœå¤±è´¥: " + e.message);
            }
        }

        function showAnalysis(analysis, displayName) {
            const modal = document.getElementById("analysisModal");
            const title = document.getElementById("modalTitle");
            const content = document.getElementById("modalContent");

            title.textContent = `ğŸ“– ${displayName} â€” çŸ¥è¯†ç‚¹åˆ†æ`;

            let html = "";

            // Book info
            const info = analysis.bookInfo;
            if (info) {
                html += `<div style="margin-bottom:20px;padding:12px;background:#f5f5f7;border-radius:8px;font-size:14px;">
                    <strong>${info.title || ""}</strong><br>
                    å‡ºç‰ˆç¤¾: ${info.publisher || ""} Â· ${info.grade || ""}${info.semester || ""}
                    ${info.startingPoint ? ` Â· ${info.startingPoint}` : ""}
                    ${info.characters?.length ? `<br>è§’è‰²: ${info.characters.join(", ")}` : ""}
                </div>`;
            }

            // Units
            const units = analysis.units || [];
            units.forEach(unit => {
                html += `<div class="unit-card">`;
                html += `<h3>${unit.unitNumber === 0 ? "Starter" : `Unit ${unit.unitNumber}`}: ${unit.unitTitle || ""}</h3>`;
                if (unit.topic) {
                    html += `<div style="color:#86868b;font-size:14px;margin-bottom:12px;">ä¸»é¢˜: ${unit.topic}</div>`;
                }

                // Vocabulary
                if (unit.vocabulary?.length) {
                    html += `<div class="unit-section"><h4>ğŸ“ ç”Ÿè¯ (${unit.vocabulary.length})</h4><div class="tag-list">`;
                    unit.vocabulary.forEach(v => {
                        html += `<span class="tag vocab" title="${v.type || ''}">${v.word} <small>${v.meaning}</small></span>`;
                    });
                    html += `</div></div>`;
                }

                // Sentence patterns
                if (unit.sentencePatterns?.length) {
                    html += `<div class="unit-section"><h4>ğŸ’¬ æ ¸å¿ƒå¥å‹</h4>`;
                    unit.sentencePatterns.forEach(s => {
                        html += `<div class="sentence-item">
                            <span class="sentence-pattern">${s.pattern || s}</span>
                            ${s.usage ? `<span class="sentence-usage">â€” ${s.usage}</span>` : ""}
                        </div>`;
                    });
                    html += `</div>`;
                }

                // Grammar
                if (unit.grammar?.length) {
                    html += `<div class="unit-section"><h4>ğŸ“ è¯­æ³•è¦ç‚¹</h4><div class="tag-list">`;
                    unit.grammar.forEach(g => {
                        html += `<span class="tag grammar">${g}</span>`;
                    });
                    html += `</div></div>`;
                }

                // Songs
                if (unit.songs?.length) {
                    html += `<div class="unit-section"><h4>ğŸµ æ­Œæ›²/æ­Œè°£</h4><div class="tag-list">`;
                    unit.songs.forEach(s => {
                        html += `<span class="tag song">${s.type === "song" ? "ğŸ¶" : "ğŸ—£ï¸"} ${s.title}${s.firstLine ? ` â€” "${s.firstLine}"` : ""}</span>`;
                    });
                    html += `</div></div>`;
                }

                // Commands
                if (unit.commands?.length) {
                    html += `<div class="unit-section"><h4>ğŸ¯ è¯¾å ‚æŒ‡ä»¤</h4><div class="tag-list">`;
                    unit.commands.forEach(c => {
                        html += `<span class="tag command">${c}</span>`;
                    });
                    html += `</div></div>`;
                }

                // Story
                if (unit.storySummary) {
                    html += `<div class="unit-section"><h4>ğŸ“– Story Time</h4>
                        <div class="story-box">${unit.storyTitle ? `<strong>${unit.storyTitle}</strong><br>` : ""}${unit.storySummary}</div>
                    </div>`;
                }

                html += `</div>`;
            });

            // Vocabulary Glossary
            const glossary = analysis.vocabularyGlossary || [];
            if (glossary.length) {
                html += `<div class="unit-card">
                    <h3>ğŸ“˜ è¯æ±‡æ€»è¡¨ (${glossary.length} è¯)</h3>
                    <table class="glossary-table">
                    <thead><tr><th>å•è¯</th><th>é‡Šä¹‰</th><th>è¯æ€§</th><th>é¦–ç°å•å…ƒ</th></tr></thead>
                    <tbody>`;
                glossary.forEach(g => {
                    html += `<tr><td><strong>${g.word}</strong></td><td>${g.meaning}</td><td>${g.type || ""}</td><td>${g.unitFirst ?? ""}</td></tr>`;
                });
                html += `</tbody></table></div>`;
            }

            content.innerHTML = html;
            modal.classList.add("active");
            document.body.style.overflow = "hidden";
        }

        function closeAnalysisModal() {
            document.getElementById("analysisModal").classList.remove("active");
            document.body.style.overflow = "";
        }
        document.getElementById("analysisModal").addEventListener("click", (e) => {
            if (e.target === e.currentTarget) closeAnalysisModal();
        });

        // Init
        init();

        // ============================
        // Tab switching
        // ============================
        function switchTab(tab) {
            const tabs = ['import', 'generate', 'reports'];
            document.querySelectorAll('.tab-btn').forEach((b, i) => {
                b.classList.toggle('active', tabs[i] === tab);
            });
            tabs.forEach(t => {
                const el = document.getElementById('tab-' + t);
                if (el) el.classList.toggle('active', t === tab);
            });
            if (tab === 'generate') loadGenDocList();
            if (tab === 'reports') loadReportTickets();
        }

        // ============================
        // Question Generation
        // ============================
        let genDocs = [];          // analyzed documents
        let genSelectedDoc = null; // currently selected doc full object
        let genSelectedUnit = null;
        let genSelectedType = null; // currently selected question type string
        let genPendingQuestions = []; // questions waiting for commit

        const QUESTION_TYPES = [
            { key: 'vocabulary',        icon: 'ğŸ“', label: 'è¯æ±‡é€‰æ‹©' },
            { key: 'cloze',             icon: 'âœï¸', label: 'å®Œå½¢å¡«ç©º' },
            { key: 'grammar',           icon: 'ğŸ“', label: 'è¯­æ³•é€‰æ‹©' },
            { key: 'multipleChoice',    icon: 'ğŸ”˜', label: 'ç»¼åˆé€‰æ‹©' },
            { key: 'errorCorrection',   icon: 'âŒ', label: 'çº é”™' },
            { key: 'translation',       icon: 'ğŸŒ', label: 'ç¿»è¯‘' },
            { key: 'rewriting',         icon: 'âœï¸', label: 'å¥å‹æ”¹å†™' },
            { key: 'sentenceOrdering',  icon: 'ğŸ”¢', label: 'å¥å­æ’åº' },
            { key: 'reading',           icon: 'ğŸ“–', label: 'é˜…è¯»ç†è§£' },
            { key: 'listening',         icon: 'ğŸ§', label: 'å¬åŠ›' },
            { key: 'speaking',          icon: 'ğŸ—£ï¸', label: 'å£è¯­' }
        ];

        async function loadGenDocList() {
            const sel = document.getElementById('genDocSelect');
            sel.innerHTML = '<option value="">â€” åŠ è½½ä¸­â€¦ â€”</option>';
            try {
                const resp = await fetch(`${API}/documents`);
                const docs = await resp.json();
                genDocs = docs.filter(d => d.hasAnalysis);
                sel.innerHTML = '<option value="">â€” é€‰æ‹©æ•™ææ–‡æ¡£ â€”</option>';
                genDocs.forEach(d => {
                    const opt = document.createElement('option');
                    opt.value = d.id;
                    opt.textContent = `${d.displayName || d.id}`;
                    opt.dataset.textbook = d.textbook;
                    sel.appendChild(opt);
                });
            } catch (e) {
                sel.innerHTML = '<option value="">åŠ è½½å¤±è´¥</option>';
            }
        }

        async function onGenDocChange() {
            const sel = document.getElementById('genDocSelect');
            const docId = sel.value;
            const info = document.getElementById('genDocInfo');
            const unitCard = document.getElementById('genUnitCard');
            const typeCard = document.getElementById('genTypeCard');
            const resultCard = document.getElementById('genResultCard');

            unitCard.style.display = 'none';
            typeCard.style.display = 'none';
            resultCard.style.display = 'none';
            document.getElementById('genFullBookCard').style.display = 'none';
            genSelectedDoc = null;
            genSelectedUnit = null;
            genSelectedType = null;
            genPendingQuestions = [];

            if (!docId) { info.style.display = 'none'; return; }

            const docMeta = genDocs.find(d => d.id === docId);
            info.style.display = 'flex';
            info.innerHTML = `<span>ğŸ“ ID: <strong>${docId}</strong></span>
                              <span>ğŸ“– ${docMeta?.displayName || docId}</span>`;

            // Fetch full document with analysis
            try {
                const resp = await fetch(`${API}/documents/${docId}/analysis?textbook=${encodeURIComponent(docMeta.textbook)}`);
                const data = await resp.json();
                if (!data.hasAnalysis) {
                    info.innerHTML += '<span style="color:#ff3b30">âŒ æœªåˆ†æ</span>';
                    return;
                }
                genSelectedDoc = { id: docId, textbook: docMeta.textbook, displayName: data.displayName, analysis: data.analysis };

                // Populate unit selector
                const unitSel = document.getElementById('genUnitSelect');
                unitSel.innerHTML = '<option value="">â€” é€‰æ‹©å•å…ƒ â€”</option>';
                data.analysis.units.forEach(u => {
                    const opt = document.createElement('option');
                    opt.value = u.unitNumber;
                    opt.textContent = `${u.unitNumber === 0 ? 'Starter' : 'Unit ' + u.unitNumber}: ${u.unitTitle || ''} (è¯æ±‡${u.vocabulary?.length || 0})`;
                    unitSel.appendChild(opt);
                });
                unitCard.style.display = 'block';

                // Show full-book card & book-level comp card
                document.getElementById('genFullBookCard').style.display = 'block';
            } catch (e) {
                info.innerHTML += `<span style="color:#ff3b30">åŠ è½½å¤±è´¥: ${e.message}</span>`;
            }
        }

        function onGenUnitChange() {
            const unitNum = parseInt(document.getElementById('genUnitSelect').value);
            const unitInfo = document.getElementById('genUnitInfo');
            const typeCard = document.getElementById('genTypeCard');
            const resultCard = document.getElementById('genResultCard');
            resultCard.style.display = 'none';
            genPendingQuestions = [];

            if (isNaN(unitNum) || !genSelectedDoc) {
                unitInfo.style.display = 'none';
                typeCard.style.display = 'none';
                return;
            }

            const unit = genSelectedDoc.analysis.units.find(u => u.unitNumber === unitNum);
            genSelectedUnit = unit;

            document.getElementById('genUnitVocab').textContent = unit.vocabulary?.length || 0;
            document.getElementById('genUnitPatterns').textContent = unit.sentencePatterns?.length || 0;
            document.getElementById('genUnitGrammar').textContent = unit.grammar?.length || 0;
            unitInfo.style.display = 'block';

            // Render unit detail (what AI will see)
            renderUnitDetail(unit);

            // Render type cards
            renderTypeGrid();
            genSelectedType = null;
            document.getElementById('generateBtn').disabled = true;
            typeCard.style.display = 'block';
        }

        function renderTypeGrid() {
            const grid = document.getElementById('typeGrid');
            grid.innerHTML = QUESTION_TYPES.map(t =>
                `<div class="type-card" data-type="${t.key}" onclick="selectType('${t.key}')">
                    <div class="type-icon">${t.icon}</div>
                    <div class="type-name">${t.label}</div>
                </div>`
            ).join('');
        }

        function renderUnitDetail(unit) {
            const el = document.getElementById('genUnitDetail');
            let html = `<div style="font-weight:700;font-size:14px;margin-bottom:8px;color:#007aff">
                ğŸ“‹ AI å°†çœ‹åˆ°çš„å•å…ƒç´ æï¼ˆç”¨äºå‡ºé¢˜ï¼‰</div>`;

            if (unit.topic) {
                html += `<div style="margin-bottom:8px"><strong>ä¸»é¢˜:</strong> ${unit.topic}</div>`;
            }

            // Vocabulary
            if (unit.vocabulary?.length) {
                html += `<div style="margin-bottom:10px"><strong>ğŸ“ è¯æ±‡ (${unit.vocabulary.length}):</strong><div class="tag-list" style="margin-top:4px">`;
                unit.vocabulary.forEach(v => {
                    html += `<span class="tag vocab">${v.word} <small>${v.meaning}</small>${v.type ? ' <small style="color:#999">[' + v.type + ']</small>' : ''}</span>`;
                });
                html += `</div></div>`;
            }

            // Sentence patterns
            if (unit.sentencePatterns?.length) {
                html += `<div style="margin-bottom:10px"><strong>ğŸ’¬ å¥å‹:</strong>`;
                unit.sentencePatterns.forEach(s => {
                    html += `<div style="padding:2px 0;font-size:13px"><code style="background:#eef;padding:2px 6px;border-radius:4px">${s.pattern || s}</code>`;
                    if (s.usage) html += ` <span style="color:#86868b">â€” ${s.usage}</span>`;
                    html += `</div>`;
                });
                html += `</div>`;
            }

            // Grammar
            if (unit.grammar?.length) {
                html += `<div style="margin-bottom:10px"><strong>ğŸ“ è¯­æ³•:</strong><div class="tag-list" style="margin-top:4px">`;
                unit.grammar.forEach(g => {
                    html += `<span class="tag grammar">${g}</span>`;
                });
                html += `</div></div>`;
            }

            // Commands
            if (unit.commands?.length) {
                html += `<div style="margin-bottom:10px"><strong>ğŸ¯ æŒ‡ä»¤:</strong><div class="tag-list" style="margin-top:4px">`;
                unit.commands.forEach(c => {
                    html += `<span class="tag command">${c}</span>`;
                });
                html += `</div></div>`;
            }

            // Songs
            if (unit.songs?.length) {
                html += `<div style="margin-bottom:10px"><strong>ğŸµ æ­Œæ›²:</strong><div class="tag-list" style="margin-top:4px">`;
                unit.songs.forEach(s => {
                    html += `<span class="tag song">${s.title}${s.firstLine ? ' â€” "' + s.firstLine + '"' : ''}</span>`;
                });
                html += `</div></div>`;
            }

            // Story
            if (unit.storySummary) {
                html += `<div style="margin-bottom:10px"><strong>ğŸ“– æ•…äº‹:</strong>
                    <div style="background:#fff;padding:8px;border-radius:6px;margin-top:4px">
                        ${unit.storyTitle ? '<strong>' + unit.storyTitle + '</strong><br>' : ''}${unit.storySummary}
                    </div></div>`;
            }

            // Also show glossary count
            const glossaryCount = genSelectedDoc.analysis.vocabularyGlossary?.length || 0;
            html += `<div style="border-top:1px solid #e5e5ea;padding-top:8px;margin-top:8px;color:#86868b">
                ğŸ“˜ å…¨ä¹¦è¯æ±‡è¡¨: ${glossaryCount} è¯ï¼ˆç”¨äºç”Ÿæˆå¹²æ‰°é¡¹ï¼‰</div>`;

            el.innerHTML = html;
        }

        function selectType(typeKey) {
            genSelectedType = typeKey;
            document.querySelectorAll('.type-card').forEach(c => {
                c.classList.toggle('selected', c.dataset.type === typeKey && !c.classList.contains('done'));
            });
            document.getElementById('generateBtn').disabled = false;
        }

        async function generateQuestions() {
            if (!genSelectedType || !genSelectedDoc || !genSelectedUnit) return;

            const typeInfo = QUESTION_TYPES.find(t => t.key === genSelectedType);
            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('genStatus');
            const resultCard = document.getElementById('genResultCard');

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> AI å‡ºé¢˜ä¸­ï¼ˆçº¦ 30~60 ç§’ï¼‰â€¦';
            status.className = 'status loading';
            status.textContent = `æ­£åœ¨ä¸º Unit ${genSelectedUnit.unitNumber} ç”Ÿæˆã€Œ${typeInfo?.label || genSelectedType}ã€é¢˜ç›®â€¦`;

            try {
                const resp = await fetch(`${API}/generate-questions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        docId: genSelectedDoc.id,
                        textbook: genSelectedDoc.textbook,
                        unitNumber: genSelectedUnit.unitNumber,
                        questionType: genSelectedType
                    })
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || 'ç”Ÿæˆå¤±è´¥');
                }

                const data = await resp.json();
                genPendingQuestions = data.questions;

                // Reset commit UI
                document.getElementById('commitBtn').disabled = false;
                document.getElementById('commitBtn').innerHTML = 'âœ… ç¡®è®¤å…¥åº“é¢˜åº“';
                document.getElementById('commitStatus').textContent = '';
                document.getElementById('commitStatus').className = 'status';

                // Mark type as done
                const typeEl = document.querySelector(`.type-card[data-type="${genSelectedType}"]`);
                if (typeEl) { typeEl.classList.add('done'); typeEl.classList.remove('selected'); }

                status.className = 'status success';
                status.textContent = `âœ… ç”Ÿæˆå®Œæˆï¼å…± ${data.count} é“ã€Œ${typeInfo?.label || genSelectedType}ã€é¢˜ã€‚è¯·å®¡æ ¸åç¡®è®¤å…¥åº“ã€‚`;

                // Show results
                showGeneratedQuestions(data.questions);
                resultCard.style.display = 'block';
            } catch (e) {
                status.className = 'status error';
                status.textContent = `âŒ ${e.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'ğŸ¤– ç”Ÿæˆé¢˜ç›®';
            }
        }

        function showGeneratedQuestions(questions) {
            // Stats
            const typeCount = {};
            questions.forEach(q => {
                const t = q.questionType || 'unknown';
                typeCount[t] = (typeCount[t] || 0) + 1;
            });
            const statsHtml = Object.entries(typeCount).map(([type, count]) =>
                `<div class="stat"><div class="num">${count}</div>${type}</div>`
            ).join('');
            document.getElementById('genStats').innerHTML = statsHtml;

            // JSON preview
            document.getElementById('genJsonPreview').textContent = JSON.stringify(questions, null, 2);

            // Visual question cards
            let cardsHtml = '';
            questions.forEach((q, i) => {
                cardsHtml += renderQuestionCard(q, i);
            });
            document.getElementById('genQuestionCards').innerHTML = cardsHtml;
            updateCommitCount();
            // Reset eval status
            document.getElementById('evalStatus').textContent = '';
            document.getElementById('evalStatus').className = 'status';
        }

        function renderQuestionCard(q, idx) {
            const type = q.questionType || 'unknown';
            const typeColors = {
                vocabulary: '#ff9500', cloze: '#007aff', grammar: '#8b5cf6',
                multipleChoice: '#34c759', errorCorrection: '#ff3b30',
                translation: '#ff9500', rewriting: '#007aff', sentenceOrdering: '#8b5cf6',
                reading: '#34c759', writing: '#ff3b30',
                listening: '#007aff', speaking: '#ff9500'
            };
            const color = typeColors[type] || '#86868b';

            let body = '';
            if (q.stem) body += `<div style="font-weight:600;margin-bottom:4px">${q.stem}</div>`;
            if (q.translation) body += `<div style="color:#86868b;font-size:13px;margin-bottom:6px">${q.translation}</div>`;
            if (q.stemTranslation) body += `<div style="color:#86868b;font-size:13px;margin-bottom:6px">${q.stemTranslation}</div>`;
            if (q.sentence) body += `<div style="font-weight:600;margin-bottom:4px">${q.sentence}</div>`;
            if (q.word) body += `<div style="font-weight:600;margin-bottom:4px">${q.word} ${q.phonetic || ''} â€” ${q.meaning || ''}</div>`;
            if (q.prompt) body += `<div style="font-weight:600;margin-bottom:4px">${q.prompt}</div>`;
            if (q.sourceText) body += `<div style="font-weight:600;margin-bottom:4px">${q.sourceText}</div>`;
            if (q.originalSentence) body += `<div style="font-weight:600;margin-bottom:4px">${q.originalSentence}</div>`;
            if (q.content) body += `<div style="background:#f9f9f9;padding:10px;border-radius:6px;font-size:13px;margin-bottom:6px;line-height:1.6;white-space:pre-wrap">${q.content}</div>`;
            if (q.transcript) body += `<div style="font-style:italic;font-size:13px;margin-bottom:6px">ğŸ§ ${q.transcript}</div>`;

            // Options
            if (q.options && Array.isArray(q.options)) {
                body += '<div style="margin:6px 0">';
                q.options.forEach((opt, oi) => {
                    const isCorrect = oi === q.correctIndex;
                    body += `<div style="padding:3px 0;font-size:13px;${isCorrect ? 'color:#34c759;font-weight:700' : ''}">${String.fromCharCode(65 + oi)}. ${opt} ${isCorrect ? 'âœ“' : ''}</div>`;
                });
                body += '</div>';
            }

            // Answer
            if (q.answer) body += `<div style="font-size:13px;color:#34c759">ç­”æ¡ˆ: ${q.answer}</div>`;
            if (q.referenceAnswer) body += `<div style="font-size:13px;color:#34c759">å‚è€ƒ: ${q.referenceAnswer}</div>`;
            if (q.referenceText) body += `<div style="font-size:13px;color:#34c759">å‚è€ƒ: ${q.referenceText}</div>`;
            if (q.correction) body += `<div style="font-size:13px;color:#34c759">æ”¹æ­£: ${q.errorRange} â†’ ${q.correction}</div>`;
            if (q.correctSentence) body += `<div style="font-size:13px;color:#34c759">æ­£ç¡®: ${q.correctSentence}</div>`;

            // Explanation
            if (q.explanation) body += `<div style="font-size:12px;color:#86868b;margin-top:4px;border-top:1px solid #f0f0f0;padding-top:4px">ğŸ’¡ ${q.explanation}</div>`;
            if (q.explanationTranslation) body += `<div style="font-size:12px;color:#86868b">${q.explanationTranslation}</div>`;

            // Sub-questions (reading) â€” field name is "questions" from GPT output
            const subs = q.subQuestions || q.questions;
            if (subs && Array.isArray(subs)) {
                body += `<div style="margin-top:10px;border-top:1px solid #e5e5ea;padding-top:8px"><div style="font-weight:700;font-size:13px;margin-bottom:6px;color:#007aff">ğŸ“‹ å­é¢˜ (${subs.length})</div>`;
                subs.forEach((sq, si) => {
                    body += `<div style="margin-top:8px;padding:10px;background:#f5f5f7;border-radius:8px;font-size:13px;border-left:3px solid #007aff">`;
                    body += `<div style="font-weight:700;margin-bottom:4px">Q${si + 1}: ${sq.stem || ''}</div>`;
                    if (sq.options) {
                        sq.options.forEach((opt, oi) => {
                            const isC = oi === sq.correctIndex;
                            body += `<div style="padding:2px 0;${isC ? 'color:#34c759;font-weight:700' : ''}">${String.fromCharCode(65 + oi)}. ${opt} ${isC ? ' âœ“' : ''}</div>`;
                        });
                    }
                    if (sq.explanation) {
                        body += `<div style="font-size:12px;color:#86868b;margin-top:4px;border-top:1px solid #e5e5ea;padding-top:4px">ğŸ’¡ ${sq.explanation}</div>`;
                    }
                    body += `</div>`;
                });
                body += `</div>`;
            }

            return `<div id="qcard-${idx}" style="border:1px solid #e5e5ea;border-radius:10px;padding:14px;margin-bottom:10px;border-left:4px solid ${color};opacity:1;transition:opacity 0.2s">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
                        <input type="checkbox" class="q-checkbox" data-idx="${idx}" checked onchange="onQuestionToggle()" style="width:16px;height:16px">
                        <span style="font-size:12px;font-weight:700;color:${color};text-transform:uppercase">#${idx + 1} ${type}${q.category ? ' Â· ' + q.category : ''}</span>
                    </label>
                    <span style="font-size:11px;color:#86868b" id="qeval-${idx}">${q.level || ''}</span>
                </div>
                ${body}
            </div>`;
        }

        function toggleJsonView() {
            const el = document.getElementById('genJsonPreview');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        // â”€â”€ Eval (AI è´¨æ£€) â”€â”€
        async function evalQuestions() {
            if (!genPendingQuestions.length) return;

            const btn = document.getElementById('evalBtn');
            const status = document.getElementById('evalStatus');

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> AI è´¨æ£€ä¸­â€¦';
            status.className = 'status loading';
            status.textContent = `æ­£åœ¨å¯¹ ${genPendingQuestions.length} é“é¢˜ç›®è¿›è¡Œè´¨æ£€â€¦`;

            try {
                const resp = await fetch(`${API}/eval-questions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ questions: genPendingQuestions, questionType: genSelectedType || 'vocabulary' })
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || 'è´¨æ£€å¤±è´¥');
                }

                const data = await resp.json();
                status.className = 'status success';
                status.textContent = `âœ… è´¨æ£€å®Œæˆï¼š${data.passed} é€šè¿‡ï¼Œ${data.failed} ä¸é€šè¿‡`;

                // Mark each question card
                data.results.forEach(r => {
                    const card = document.getElementById(`qcard-${r.index}`);
                    const evalLabel = document.getElementById(`qeval-${r.index}`);
                    const checkbox = document.querySelector(`.q-checkbox[data-idx="${r.index}"]`);
                    if (!card) return;

                    if (r.pass) {
                        evalLabel.innerHTML = '<span style="color:#34c759;font-weight:700">âœ… é€šè¿‡</span>';
                    } else {
                        evalLabel.innerHTML = `<span style="color:#ff3b30;font-weight:700">âŒ ä¸é€šè¿‡</span>`;
                        // Add issue details
                        const issueDiv = document.createElement('div');
                        issueDiv.style.cssText = 'background:#fff5f5;border:1px solid #ff3b30;border-radius:6px;padding:8px;margin-top:6px;font-size:12px;color:#ff3b30';
                        issueDiv.innerHTML = r.issues.map(i => `â€¢ ${i}`).join('<br>');
                        card.appendChild(issueDiv);
                        // Uncheck failed questions
                        if (checkbox) {
                            checkbox.checked = false;
                            card.style.opacity = '0.5';
                        }
                    }
                });
                updateCommitCount();
            } catch (e) {
                status.className = 'status error';
                status.textContent = `âŒ ${e.message}`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'ğŸ” AI è´¨æ£€';
            }
        }

        // â”€â”€ Checkbox controls â”€â”€
        function onQuestionToggle() {
            document.querySelectorAll('.q-checkbox').forEach(cb => {
                const card = document.getElementById(`qcard-${cb.dataset.idx}`);
                if (card) card.style.opacity = cb.checked ? '1' : '0.5';
            });
            updateCommitCount();
        }

        function toggleAllQuestions(checked) {
            document.querySelectorAll('.q-checkbox').forEach(cb => {
                cb.checked = checked;
                const card = document.getElementById(`qcard-${cb.dataset.idx}`);
                if (card) card.style.opacity = checked ? '1' : '0.5';
            });
            updateCommitCount();
        }

        function updateCommitCount() {
            const checked = document.querySelectorAll('.q-checkbox:checked').length;
            const total = document.querySelectorAll('.q-checkbox').length;
            document.getElementById('commitCount').textContent = `å·²é€‰ ${checked}/${total} é“`;
        }

        // â”€â”€ Commit (only checked questions) â”€â”€
        async function commitQuestions() {
            const checkedIdxs = new Set();
            document.querySelectorAll('.q-checkbox:checked').forEach(cb => {
                checkedIdxs.add(parseInt(cb.dataset.idx));
            });
            const selected = genPendingQuestions.filter((_, i) => checkedIdxs.has(i));
            if (!selected.length) {
                alert('æ²¡æœ‰é€‰ä¸­ä»»ä½•é¢˜ç›®');
                return;
            }
            if (!confirm(`ç¡®è®¤å°† ${selected.length} é“é¢˜ç›®å…¥åº“ï¼Ÿ`)) return;

            const btn = document.getElementById('commitBtn');
            const status = document.getElementById('commitStatus');

            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> å…¥åº“ä¸­â€¦';

            try {
                const resp = await fetch(`${API}/commit-questions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ questions: selected })
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || 'å…¥åº“å¤±è´¥');
                }

                const data = await resp.json();
                status.className = 'status success';
                status.textContent = `âœ… å…¥åº“æˆåŠŸï¼å…±å†™å…¥ ${data.committed}/${data.total} é“é¢˜ç›®åˆ° questions å®¹å™¨ã€‚`;

                if (data.errors?.length) {
                    status.textContent += ` âš ï¸ ${data.errors.length} ä¸ªé”™è¯¯ã€‚`;
                }

                genPendingQuestions = [];
                btn.disabled = true;
                btn.innerHTML = 'âœ… å·²å…¥åº“';
            } catch (e) {
                status.className = 'status error';
                status.textContent = `âŒ ${e.message}`;
                btn.disabled = false;
                btn.innerHTML = 'âœ… ç¡®è®¤å…¥åº“é¢˜åº“';
            }
        }

        function discardQuestions() {
            if (!confirm('ç¡®è®¤ä¸¢å¼ƒå½“å‰ç”Ÿæˆçš„é¢˜ç›®ï¼Ÿ')) return;
            genPendingQuestions = [];
            document.getElementById('genResultCard').style.display = 'none';
            document.getElementById('genStatus').className = 'status';
        }

        // ===== Full-book generation: server-side background job =====
        let fullBookJobId = null;
        let fullBookPollTimer = null;
        let fullBookLogVersion = 0;

        function fullBookLog(msg, color) {
            const log = document.getElementById('fullBookLog');
            const line = document.createElement('div');
            const time = new Date().toLocaleTimeString();
            line.innerHTML = `<span style="color:#86868b">[${time}]</span> ${color ? `<span style="color:${color}">${msg}</span>` : msg}`;
            log.appendChild(line);
            log.scrollTop = log.scrollHeight;
        }

        function fullBookLogFromServer(entry) {
            const log = document.getElementById('fullBookLog');
            const line = document.createElement('div');
            const time = new Date(entry.time).toLocaleTimeString();
            const msg = entry.color ? `<span style="color:${entry.color}">${entry.message}</span>` : entry.message;
            line.innerHTML = `<span style="color:#86868b">[${time}]</span> ${msg}`;
            log.appendChild(line);
            log.scrollTop = log.scrollHeight;
        }

        function updateFullBookUI(data) {
            const pct = data.progress || 0;
            document.getElementById('fullBookProgressBar').style.width = pct + '%';
            document.getElementById('fullBookProgressText').textContent = Math.round(pct) + '%';
            document.getElementById('fullBookProgressCount').textContent = `${data.completedSteps}/${data.totalSteps}`;
            document.getElementById('fullBookSummary').innerHTML =
                `å·²ç”Ÿæˆ <strong>${data.totalGenerated}</strong> é“ Â· ` +
                `å·²å…¥åº“ <strong style="color:#34c759">${data.totalCommitted}</strong> é“ Â· ` +
                `å¤±è´¥ <strong style="color:${data.errorCount ? '#ff3b30' : '#86868b'}">${data.errorCount}</strong> ä¸ª / å…± ${data.totalSteps} æ­¥`;

            // Append new log entries
            if (data.logs) {
                data.logs.forEach(e => fullBookLogFromServer(e));
                fullBookLogVersion = data.logVersion;
            }

            // Button states
            const status = data.status;
            const isActive = status === 'running' || status === 'queued';
            const isCancelled = status === 'cancelled';
            document.getElementById('fullBookBtn').disabled = isActive;
            document.getElementById('fullBookCancelBtn').style.display = isActive ? 'inline-block' : 'none';
            document.getElementById('fullBookResumeBtn').style.display = isCancelled ? 'inline-block' : 'none';

            const statusEl = document.getElementById('fullBookStatus');
            if (status === 'completed') {
                statusEl.className = 'status success';
                statusEl.textContent = `âœ… å®Œæˆï¼å…±å…¥åº“ ${data.totalCommitted} é“é¢˜ç›®ï¼Œ${data.errorCount} ä¸ªé”™è¯¯ã€‚`;
            } else if (status === 'cancelled') {
                statusEl.className = 'status error';
                statusEl.textContent = `å·²åœæ­¢ â€” å·²å…¥åº“ ${data.totalCommitted} é“ï¼Œå¯ç‚¹â€œæ¢å¤â€ç»§ç»­ã€‚`;
            } else if (status === 'failed') {
                statusEl.className = 'status error';
                statusEl.textContent = `å¤±è´¥ â€” ${data.errorCount} ä¸ªé”™è¯¯ã€‚`;
            } else {
                statusEl.className = 'status';
                statusEl.textContent = data.currentStep ? `æ­£åœ¨å¤„ç†: ${data.currentStep}` : 'æ’é˜Ÿä¸­â€¦';
            }

            // Stop polling if job finished
            if (!isActive && fullBookPollTimer) {
                clearInterval(fullBookPollTimer);
                fullBookPollTimer = null;
            }
        }

        function startFullBookPolling() {
            if (fullBookPollTimer) clearInterval(fullBookPollTimer);
            fullBookPollTimer = setInterval(async () => {
                if (!fullBookJobId) return;
                try {
                    const resp = await fetch(`${API}/jobs/${fullBookJobId}?logSince=${fullBookLogVersion}`);
                    if (resp.ok) {
                        const data = await resp.json();
                        updateFullBookUI(data);
                    }
                } catch (e) {
                    console.warn('Poll error:', e);
                }
            }, 3000);
        }

        async function startFullBookJob() {
            if (!genSelectedDoc) return;

            // Reset UI
            document.getElementById('fullBookLog').innerHTML = '';
            document.getElementById('fullBookProgress').style.display = 'block';
            document.getElementById('fullBookProgressBar').style.width = '0%';
            document.getElementById('fullBookProgressText').textContent = '0%';
            document.getElementById('fullBookProgressCount').textContent = '0/0';
            document.getElementById('fullBookSummary').textContent = '';
            document.getElementById('fullBookStatus').className = 'status';
            document.getElementById('fullBookStatus').textContent = '';
            document.getElementById('fullBookBtn').disabled = true;
            document.getElementById('fullBookCancelBtn').style.display = 'inline-block';
            document.getElementById('fullBookResumeBtn').style.display = 'none';
            fullBookLogVersion = 0;

            fullBookLog('ğŸš€ æ­£åœ¨æäº¤åå°ä»»åŠ¡â€¦');

            try {
                const resp = await fetch(`${API}/jobs/full-book`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        docId: genSelectedDoc.id,
                        textbook: genSelectedDoc.textbook
                    })
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    throw new Error(err.detail || `HTTP ${resp.status}`);
                }

                const data = await resp.json();
                fullBookJobId = data.jobId;
                fullBookLog(`âœ… ä»»åŠ¡å·²æäº¤ï¼ŒjobId: ${data.jobId}`);
                startFullBookPolling();
            } catch (e) {
                fullBookLog(`âŒ æäº¤å¤±è´¥: ${e.message}`, '#ff3b30');
                document.getElementById('fullBookBtn').disabled = false;
                document.getElementById('fullBookCancelBtn').style.display = 'none';
            }
        }

        async function cancelFullBookJob() {
            if (!fullBookJobId) return;
            try {
                await fetch(`${API}/jobs/${fullBookJobId}/cancel`, { method: 'POST' });
                fullBookLog('â¹ å·²å‘é€åœæ­¢è¯·æ±‚â€¦', '#ff9500');
            } catch (e) {
                fullBookLog(`âŒ åœæ­¢å¤±è´¥: ${e.message}`, '#ff3b30');
            }
        }

        async function resumeFullBookJob() {
            if (!fullBookJobId) return;
            try {
                const resp = await fetch(`${API}/jobs/${fullBookJobId}/resume`, { method: 'POST' });
                if (resp.ok) {
                    fullBookLog('â–¶ï¸ å·²æ¢å¤ï¼Œç»§ç»­å¾…å¤„ç†æ­¥éª¤â€¦', '#34c759');
                    document.getElementById('fullBookResumeBtn').style.display = 'none';
                    document.getElementById('fullBookCancelBtn').style.display = 'inline-block';
                    document.getElementById('fullBookBtn').disabled = true;
                    startFullBookPolling();
                } else {
                    const err = await resp.json();
                    fullBookLog(`âŒ æ¢å¤å¤±è´¥: ${err.detail}`, '#ff3b30');
                }
            } catch (e) {
                fullBookLog(`âŒ æ¢å¤å¤±è´¥: ${e.message}`, '#ff3b30');
            }
        }

        // ============================
        // Report Ticket Management
        // ============================

        let reportOffset = 0;
        const REPORT_PAGE_SIZE = 20;

        // Load badge count on init
        loadReportBadge();

        async function loadReportBadge() {
            try {
                const resp = await fetch(`${API}/reports?offset=0&limit=1`);
                const data = await resp.json();
                const badge = document.getElementById('reportBadge');
                if (data.total > 0) {
                    badge.textContent = data.total;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }
            } catch (e) { /* silent */ }
        }

        async function loadReportTickets() {
            const container = document.getElementById('reportTicketList');
            container.innerHTML = '<p style="color:#86868b;font-size:14px;">åŠ è½½ä¸­â€¦</p>';

            try {
                const resp = await fetch(`${API}/reports?offset=${reportOffset}&limit=${REPORT_PAGE_SIZE}`);
                const data = await resp.json();
                const summary = document.getElementById('reportSummary');
                summary.textContent = `å…± ${data.total} æ¡ä¸¾æŠ¥`;

                // Update badge
                const badge = document.getElementById('reportBadge');
                if (data.total > 0) {
                    badge.textContent = data.total;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }

                if (!data.items || data.items.length === 0) {
                    container.innerHTML = '<p style="color:#86868b;font-size:14px;">ğŸ‰ æ²¡æœ‰ä¸¾æŠ¥å·¥å•</p>';
                    document.getElementById('reportPaging').style.display = 'none';
                    return;
                }

                let html = '<table class="inventory-table"><thead><tr>' +
                    '<th>ä¸¾æŠ¥æ¬¡æ•°</th><th>é¢˜ç›® ID</th><th>é¢˜å‹</th><th>é”™è¯¯ç±»å‹</th><th>è¡¥å……è¯´æ˜</th><th>æœ€è¿‘ä¸¾æŠ¥</th><th>æ“ä½œ</th>' +
                    '</tr></thead><tbody>';

                for (const item of data.items) {
                    const shortId = item.id.length > 16 ? item.id.substring(0, 14) + 'â€¦' : item.id;
                    const typeBadge = item.questionType
                        ? `<span class="badge badge-ai">${item.questionType}</span>`
                        : '<span class="badge badge-empty">â€”</span>';
                    const reasonBadge = item.reason
                        ? `<span class="badge" style="background:#ff9500;color:#fff;">${item.reason}</span>`
                        : '<span style="color:#ccc;">â€”</span>';
                    const descText = item.latestDescription
                        ? `<span title="${item.latestDescription}" style="font-size:12px;max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:inline-block;">${item.latestDescription}</span>`
                        : '<span style="color:#ccc;">â€”</span>';
                    const lastTime = item.lastReportedAt ? new Date(item.lastReportedAt).toLocaleString('zh-CN') : 'â€”';

                    html += `<tr>
                        <td><strong style="color:#ff3b30;font-size:18px;">${item.reportCount}</strong></td>
                        <td style="font-family:monospace;font-size:12px;" title="${item.id}">${shortId}</td>
                        <td>${typeBadge}</td>
                        <td>${reasonBadge}</td>
                        <td>${descText}</td>
                        <td style="font-size:12px;color:#86868b;">${lastTime}</td>
                        <td style="white-space:nowrap;">
                            <button class="btn btn-sm btn-primary" onclick="viewReportedQuestion('${item.id}')" style="margin-right:4px;">
                                ğŸ‘€ æŸ¥çœ‹
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteReportedQuestion('${item.id}')">
                                ğŸ—‘ï¸ åˆ é¢˜
                            </button>
                            <button class="btn btn-sm" onclick="dismissReport('${item.id}')" style="background:#86868b;color:#fff;margin-left:4px;">
                                å¿½ç•¥
                            </button>
                        </td>
                    </tr>`;
                }

                html += '</tbody></table>';
                container.innerHTML = html;

                // Paging controls
                const paging = document.getElementById('reportPaging');
                const totalPages = Math.ceil(data.total / REPORT_PAGE_SIZE);
                const currentPage = Math.floor(reportOffset / REPORT_PAGE_SIZE) + 1;
                paging.style.display = totalPages > 1 ? 'flex' : 'none';
                document.getElementById('reportPageInfo').textContent = `ç¬¬ ${currentPage} / ${totalPages} é¡µ`;
                document.getElementById('reportPrevBtn').disabled = reportOffset === 0;
                document.getElementById('reportNextBtn').disabled = reportOffset + REPORT_PAGE_SIZE >= data.total;
            } catch (e) {
                container.innerHTML = `<p style="color:#ff3b30;">åŠ è½½å¤±è´¥: ${e.message}</p>`;
            }
        }

        function reportPagePrev() {
            reportOffset = Math.max(0, reportOffset - REPORT_PAGE_SIZE);
            loadReportTickets();
        }
        function reportPageNext() {
            reportOffset += REPORT_PAGE_SIZE;
            loadReportTickets();
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        async function viewReportedQuestion(questionId) {
            const modal = document.getElementById('reportDetailModal');
            const content = document.getElementById('reportModalContent');
            content.innerHTML = '<p>åŠ è½½ä¸­â€¦</p>';
            modal.classList.add('active');

            try {
                const resp = await fetch(`${API}/questions/${questionId}`);
                if (!resp.ok) {
                    content.innerHTML = '<p style="color:#ff3b30;">é¢˜ç›®ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤</p>';
                    return;
                }
                const question = await resp.json();

                let html = '<div style="margin-bottom:16px;">';
                html += `<div style="font-size:13px;color:#86868b;margin-bottom:8px;">ID: <code>${questionId}</code></div>`;

                if (question.questionType) html += `<div style="margin-bottom:8px;"><span class="badge badge-ai">${question.questionType}</span></div>`;
                if (question.textbookCode) html += `<div style="font-size:13px;margin-bottom:8px;">æ•™æ: <strong>${question.textbookCode}</strong></div>`;

                if (question.stem) html += `<div style="margin-bottom:8px;"><strong>é¢˜å¹²:</strong> ${escapeHtml(question.stem)}</div>`;
                if (question.sentence) html += `<div style="margin-bottom:8px;"><strong>å¥å­:</strong> ${escapeHtml(question.sentence)}</div>`;
                if (question.passage) html += `<div style="margin-bottom:8px;"><strong>æ–‡ç« :</strong><div style="background:#f9f9fb;border-radius:8px;padding:12px;font-size:13px;max-height:200px;overflow-y:auto;">${escapeHtml(question.passage)}</div></div>`;

                if (question.options) {
                    html += '<div style="margin-bottom:8px;"><strong>é€‰é¡¹:</strong><ul style="margin:4px 0;padding-left:20px;">';
                    question.options.forEach((opt, i) => {
                        const label = String.fromCharCode(65 + i);
                        const isCorrect = i === question.correctIndex;
                        html += `<li style="${isCorrect ? 'color:#34c759;font-weight:700;' : ''}">${label}. ${escapeHtml(typeof opt === 'string' ? opt : JSON.stringify(opt))}${isCorrect ? ' âœ…' : ''}</li>`;
                    });
                    html += '</ul></div>';
                }

                if (question.answer) html += `<div style="margin-bottom:8px;"><strong>ç­”æ¡ˆ:</strong> <span style="color:#34c759;font-weight:700;">${escapeHtml(String(question.answer))}</span></div>`;
                if (question.explanation) html += `<div style="margin-bottom:8px;"><strong>è§£æ:</strong> ${escapeHtml(question.explanation)}</div>`;

                html += '</div>';

                html += '<details style="margin-top:16px;"><summary style="cursor:pointer;font-size:13px;color:#007aff;">ğŸ“‹ å®Œæ•´ JSON</summary>';
                html += `<pre style="background:#1d1d1f;color:#f5f5f7;border-radius:10px;padding:16px;max-height:400px;overflow-y:auto;font-size:12px;margin-top:8px;">${escapeHtml(JSON.stringify(question, null, 2))}</pre>`;
                html += '</details>';

                html += `<div style="display:flex;gap:12px;margin-top:20px;padding-top:16px;border-top:1px solid #e5e5ea;">
                    <button class="btn btn-danger" onclick="deleteReportedQuestion('${questionId}');closeReportDetailModal();">ğŸ—‘ï¸ åˆ é™¤æ­¤é¢˜</button>
                    <button class="btn" onclick="dismissReport('${questionId}');closeReportDetailModal();" style="background:#86868b;color:#fff;">å¿½ç•¥ä¸¾æŠ¥</button>
                    <button class="btn" onclick="closeReportDetailModal();" style="background:#e5e5ea;color:#1d1d1f;">å…³é—­</button>
                </div>`;

                content.innerHTML = html;
            } catch (e) {
                content.innerHTML = `<p style="color:#ff3b30;">åŠ è½½å¤±è´¥: ${e.message}</p>`;
            }
        }

        function closeReportDetailModal() {
            document.getElementById('reportDetailModal').classList.remove('active');
        }

        async function deleteReportedQuestion(questionId) {
            if (!confirm(`ç¡®è®¤åˆ é™¤é¢˜ç›® ${questionId.substring(0, 14)}â€¦ï¼Ÿ\nåˆ é™¤åä¸å¯æ¢å¤ï¼`)) return;

            try {
                const qResp = await fetch(`${API}/questions/${questionId}`);
                if (!qResp.ok) {
                    alert('é¢˜ç›®ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤');
                    loadReportTickets();
                    return;
                }
                const question = await qResp.json();
                const textbookCode = question.textbookCode;
                if (!textbookCode) { alert('æ— æ³•è·å– textbookCode'); return; }

                const resp = await fetch(`${API}/reports/${questionId}/question?textbookCode=${encodeURIComponent(textbookCode)}`, {
                    method: 'DELETE'
                });
                if (resp.ok) {
                    alert('âœ… é¢˜ç›®å·²åˆ é™¤');
                    loadReportTickets();
                } else {
                    const err = await resp.json();
                    alert(`åˆ é™¤å¤±è´¥: ${err.detail || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (e) {
                alert(`åˆ é™¤å¤±è´¥: ${e.message}`);
            }
        }

        async function dismissReport(questionId) {
            try {
                const resp = await fetch(`${API}/reports/${questionId}`, { method: 'DELETE' });
                if (resp.ok) {
                    loadReportTickets();
                } else {
                    const err = await resp.json();
                    alert(`æ“ä½œå¤±è´¥: ${err.detail || 'æœªçŸ¥é”™è¯¯'}`);
                }
            } catch (e) {
                alert(`æ“ä½œå¤±è´¥: ${e.message}`);
            }
        }

    </script>
</body>
</html>
